@article{10.1145/3428194,
author = {Brachth\"{a}user, Jonathan Immanuel and Schuster, Philipp and Ostermann, Klaus},
title = {Effects as Capabilities: Effect Handlers and Lightweight Effect Polymorphism},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428194},
doi = {10.1145/3428194},
abstract = {Effect handlers have recently gained popularity amongst programming language researchers. Existing type- and effect systems for effect handlers are often complicated and potentially hinder a wide-spread adoption. We present the language Effekt with the goal to close the gap between research languages with effect handlers and languages for working programmers. The design of Effekt revolves around a different view of effects and effect types. Traditionally, effect types express which side effects a computation might have. In Effekt, effect types express which capabilities a computation requires from its context. While this new point in the design space of effect systems impedes reasoning about purity, we demonstrate that it simplifies the treatment of effect polymorphism and the related issues of effect parametricity and effect encapsulation. To guarantee effect safety, we separate functions from values and treat all functions as second-class. We define the semantics of Effekt as a translation to System Xi, a calculus in explicit capability-passing style.},
journal = {Proc. ACM Program. Lang.},
month = {nov},
articleno = {126},
numpages = {30},
keywords = {algebraic effects, effect polymorphism, effect handlers}
}

@article{10.1145/2858949.2784763,
author = {Rendel, Tillmann and Trieflinger, Julia and Ostermann, Klaus},
title = {Automatic Refunctionalization to a Language with Copattern Matching: With Applications to the Expression Problem},
year = {2015},
issue_date = {September 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2858949.2784763},
doi = {10.1145/2858949.2784763},
abstract = {Defunctionalization and refunctionalization establish a correspondence between first-class functions and pattern matching, but the correspondence is not symmetric: Not all uses of pattern matching can be automatically refunctionalized to uses of higher-order functions. To remedy this asymmetry, we generalize from first-class functions to arbitrary codata. This leads us to full defunctionalization and refunctionalization between a codata language based on copattern matching and a data language based on pattern matching. We observe how programs can be written as matrices so that they are modularly extensible in one dimension but not the other. In this representation, defunctionalization and refunctionalization correspond to matrix transposition which effectively changes the dimension of extensibility a program supports. This suggests applications to the expression problem.},
journal = {SIGPLAN Not.},
month = {aug},
pages = {269â€“279},
numpages = {11},
keywords = {Copattern Matching, Codata, Expression Problem, Defunctionalization, Uroboro, Refunctionalization}
}
